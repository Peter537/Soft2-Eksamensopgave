@page "/partner/{PartnerId:int}/incoming-orders"
@rendermode InteractiveServer
@inject IConfiguration Configuration
@inject IJSRuntime JS
@inject HttpClient Http
@inject AuthService Auth
@inject NavigationManager Navigation
@inject CultureService CultureService
@inject ILocalizerService L
@implements IAsyncDisposable

<PageTitle>@L.GetString("Pages.Partner.IncomingOrders.PageTitle", PartnerId)</PageTitle>

<div class="container mt-4">
    @if (!isInitialized)
    {
        <div class="text-center">
            <div class="spinner-border" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
        </div>
    }
    else if (!Auth.IsPartner || Auth.Id != PartnerId)
    {
        <div class="row justify-content-center">
            <div class="col-md-6">
                <div class="alert alert-warning">
                    <h5 class="alert-heading">@L["Pages.Partner.IncomingOrders.AccessDeniedTitle"]</h5>
                    <p class="mb-0">@L["Pages.Partner.IncomingOrders.LoginRequired"] <a href="/partner/login">@L["Pages.Partner.IncomingOrders.LoginLink"]</a></p>
                </div>
            </div>
        </div>
    }
    else
    {
        <h3>@L["Pages.Partner.IncomingOrders.Title"]</h3>

        <div class="row">
    @* Left Column: New Orders *@
    <div class="col-md-6">
        <div class="card">
            <div class="card-header bg-warning text-dark">
                <h5 class="mb-0">
                    <span class="oi oi-bell me-2"></span>
                    New Orders (@NewOrders.Count)
                </h5>
            </div>
            <div class="card-body" style="min-height: 400px; max-height: 600px; overflow-y: auto;">
                @if (NewOrders.Count == 0)
                {
                    <p class="text-muted text-center mt-4">
                        <span class="oi oi-inbox" style="font-size: 2rem;"></span><br />
                        Waiting for new orders...
                    </p>
                }
                else
                {
                    @foreach (var order in NewOrders.OrderByDescending(o => o.ReceivedAt))
                    {
                        <div class="card mb-3 border-warning">
                            <div class="card-body">
                                <div class="d-flex justify-content-between">
                                    <h6 class="card-title">Order #@order.OrderId</h6>
                                    <small class="text-muted">@order.ReceivedAt.ToString("HH:mm:ss")</small>
                                </div>
                                @if (!string.IsNullOrEmpty(order.Distance))
                                {
                                    <p class="text-info mb-1"><small>üìç Distance: @order.Distance</small></p>
                                }
                                <ul class="list-unstyled mb-2">
                                    @foreach (var item in order.Items)
                                    {
                                        <li>@item.Quantity x @item.Name</li>
                                    }
                                </ul>
                                <div class="mb-2">
                                    <label class="form-label small mb-1">Estimated prep time (minutes)*</label>
                                    <input type="number" 
                                           class="form-control form-control-sm" 
                                           min="1" 
                                           max="120"
                                           placeholder="e.g. 15"
                                           @bind="order.EstimatedMinutes" />
                                </div>
                                <div class="d-flex gap-2">
                                    <button class="btn btn-success btn-sm" 
                                            disabled="@(!order.EstimatedMinutes.HasValue || order.EstimatedMinutes < 1)"
                                            @onclick="() => AcceptOrder(order)">
                                        Accept
                                    </button>
                                    <button class="btn btn-danger btn-sm" @onclick="() => RejectOrder(order)">
                                        Reject
                                    </button>
                                </div>
                            </div>
                        </div>
                    }
                }
            </div>
        </div>
    </div>

    @* Right Column: Accepted Orders *@
    <div class="col-md-6">
        <div class="card">
            <div class="card-header bg-success text-white">
                <h5 class="mb-0">
                    <span class="oi oi-check me-2"></span>
                    Accepted Orders (@AcceptedOrders.Count)
                </h5>
            </div>
            <div class="card-body" style="min-height: 400px; max-height: 600px; overflow-y: auto;">
                @if (AcceptedOrders.Count == 0)
                {
                    <p class="text-muted text-center mt-4">
                        <span class="oi oi-list" style="font-size: 2rem;"></span><br />
                        No accepted orders yet
                    </p>
                }
                else
                {
                    @foreach (var order in AcceptedOrders.OrderByDescending(o => o.AcceptedAt))
                    {
                        <div class="card mb-3 border-success">
                            <div class="card-body">
                                <div class="d-flex justify-content-between">
                                    <h6 class="card-title">Order #@order.OrderId</h6>
                                    <span class="badge @(order.AgentId.HasValue ? "bg-info" : "bg-secondary")">
                                        @(order.AgentId.HasValue ? $"Agent #{order.AgentId}" : "Awaiting agent")
                                    </span>
                                </div>
                                <ul class="list-unstyled mb-2">
                                    @foreach (var item in order.Items)
                                    {
                                        <li>@item.Quantity x @item.Name</li>
                                    }
                                </ul>
                                <div class="d-flex justify-content-between align-items-center">
                                    <small class="text-muted">Accepted at @order.AcceptedAt?.ToString("HH:mm:ss")</small>
                                    @if (!order.IsReady)
                                    {
                                        <button class="btn btn-primary btn-sm" @onclick="() => MarkFoodReady(order)">
                                            Food Ready
                                        </button>
                                    }
                                    else
                                    {
                                        <span class="badge bg-success">Ready for pickup</span>
                                    }
                                </div>
                            </div>
                        </div>
                    }
                }
            </div>
        </div>
    </div>
</div>

@* Connection Status *@
<div class="mt-3">
    <span class="badge @(IsConnected ? "bg-success" : "bg-danger")">
        @(IsConnected ? "Connected" : "Disconnected")
    </span>
    @if (!string.IsNullOrEmpty(StatusMessage))
    {
        <span class="ms-2 text-muted">@StatusMessage</span>
    }
</div>
    }
</div>

@code {
    [Parameter]
    public int PartnerId { get; set; }

    private List<IncomingOrder> NewOrders { get; set; } = new();
    private List<AcceptedOrder> AcceptedOrders { get; set; } = new();
    private bool IsConnected { get; set; }
    private string StatusMessage { get; set; } = "Connecting...";
    private bool isInitialized;

    private DotNetObjectReference<IncomingOrders>? _dotNetRef;

    protected override void OnInitialized()
    {
        CultureService.OnChange += OnCultureChanged;
    }

    private void OnCultureChanged()
    {
        InvokeAsync(StateHasChanged);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await Auth.InitializeAsync();
            isInitialized = true;
            
            if (Auth.IsPartner && Auth.Id == PartnerId)
            {
                _dotNetRef = DotNetObjectReference.Create(this);
                
                // PublicUrl for browser, GatewayUrl is internal docker hostname
                var gatewayUrl = Configuration["GatewayPublicUrl"] ?? Configuration["GatewayUrl"] ?? "http://localhost:8080";
                var wsUrl = gatewayUrl.Replace("http://", "ws://").Replace("https://", "wss://");
                wsUrl = $"{wsUrl}/api/v1/ws/partners/{PartnerId}";

                await JS.InvokeVoidAsync("partnerWebSocket.connect", wsUrl, _dotNetRef);
            }
            StateHasChanged();
        }
    }

    [JSInvokable]
    public void OnConnected()
    {
        IsConnected = true;
        StatusMessage = "Listening for orders...";
        InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public void OnDisconnected(string reason)
    {
        IsConnected = false;
        StatusMessage = $"Disconnected: {reason}";
        InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public void OnOrderCreated(int orderId, string orderCreatedTime, string distance, OrderItemDto[] items)
    {
        var order = new IncomingOrder
        {
            OrderId = orderId,
            OrderCreatedTime = orderCreatedTime,
            Distance = distance,
            Items = items.ToList(),
            ReceivedAt = DateTime.Now
        };

        NewOrders.Add(order);
        StatusMessage = $"New order #{orderId} received!";
        InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public void OnAgentAssigned(int orderId, int agentId)
    {
        var order = AcceptedOrders.FirstOrDefault(o => o.OrderId == orderId);
        if (order != null)
        {
            order.AgentId = agentId;
            StatusMessage = $"Agent #{agentId} assigned to order #{orderId}";
            InvokeAsync(StateHasChanged);
        }
    }

    [JSInvokable]
    public void OnOrderPickedUp(int orderId)
    {
        var order = AcceptedOrders.FirstOrDefault(o => o.OrderId == orderId);
        if (order != null)
        {
            AcceptedOrders.Remove(order);
            StatusMessage = $"Order #{orderId} picked up by agent!";
            InvokeAsync(StateHasChanged);
        }
    }

    private async Task AcceptOrder(IncomingOrder order)
    {
        NewOrders.Remove(order);
        AcceptedOrders.Add(new AcceptedOrder
        {
            OrderId = order.OrderId,
            Items = order.Items,
            Distance = order.Distance,
            EstimatedMinutes = order.EstimatedMinutes ?? 0,
            AcceptedAt = DateTime.Now,
            AgentId = null
        });

        // Call Gateway to accept order
        var gatewayUrl = Configuration["GatewayUrl"] ?? "http://localhost:8080";
        StatusMessage = $"Order #{order.OrderId} accepted! ETA: {order.EstimatedMinutes} min";
        
        try
        {
            var payload = new { estimatedMinutes = order.EstimatedMinutes ?? 15 };
            var response = await Http.PostAsJsonAsync($"{gatewayUrl}/api/v1/orders/order/{order.OrderId}/accept", payload);
            if (!response.IsSuccessStatusCode)
            {
                StatusMessage = $"Order #{order.OrderId} accepted locally, but API call failed: {response.StatusCode}";
            }
        }
        catch (Exception ex)
        {
            StatusMessage = $"Order #{order.OrderId} accepted locally, API error: {ex.Message}";
        }
        
        await InvokeAsync(StateHasChanged);
    }

    private async Task RejectOrder(IncomingOrder order)
    {
        NewOrders.Remove(order);
        StatusMessage = $"Order #{order.OrderId} rejected";

        var gatewayUrl = Configuration["GatewayUrl"] ?? "http://localhost:8080";
        try
        {
            await Http.PostAsJsonAsync($"{gatewayUrl}/api/v1/orders/order/{order.OrderId}/reject", new { reason = "Partner rejected" });
        }
        catch
        {
            // Fire-and-forget, UI already updated
        }

        await InvokeAsync(StateHasChanged);
    }

    private async Task MarkFoodReady(AcceptedOrder order)
    {
        order.IsReady = true;
        StatusMessage = $"Order #{order.OrderId} marked as ready!";

        var gatewayUrl = Configuration["GatewayUrl"] ?? "http://localhost:8080";
        try
        {
            await Http.PostAsync($"{gatewayUrl}/api/v1/orders/order/{order.OrderId}/set-ready", null);
        }
        catch
        {
            // Fire-and-forget, UI already updated
        }

        await InvokeAsync(StateHasChanged);
    }

    public async ValueTask DisposeAsync()
    {
        CultureService.OnChange -= OnCultureChanged;
        if (_dotNetRef != null)
        {
            await JS.InvokeVoidAsync("partnerWebSocket.disconnect");
            _dotNetRef.Dispose();
        }
    }

    public class IncomingOrder
    {
        public int OrderId { get; set; }
        public string OrderCreatedTime { get; set; } = "";
        public string Distance { get; set; } = "";
        public List<OrderItemDto> Items { get; set; } = new();
        public DateTime ReceivedAt { get; set; }
        public int? EstimatedMinutes { get; set; }
    }

    public class AcceptedOrder
    {
        public int OrderId { get; set; }
        public List<OrderItemDto> Items { get; set; } = new();
        public string Distance { get; set; } = "";
        public int EstimatedMinutes { get; set; }
        public DateTime? AcceptedAt { get; set; }
        public int? AgentId { get; set; }
        public bool IsReady { get; set; }
    }

    public class OrderItemDto
    {
        public string Name { get; set; } = "";
        public int Quantity { get; set; }
    }
}
