# ===========================================
# Azure Infrastructure Deploy Workflow
# ===========================================
# This workflow deploys the MToGo platform to Azure Kubernetes Service.
# It can be triggered manually or after successful CI builds on main.
#
# Prerequisites:
#   1. Azure Service Principal with Contributor access
#   2. GitHub secrets configured (see documentation)

name: Azure Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "prod"
        type: choice
        options:
          - dev
          - prod
          - staging
      image_tag:
        description: "Docker image tag to deploy (leave empty for latest main)"
        required: false
        default: ""
      node_count:
        description: "Number of AKS nodes"
        required: false
        default: "1"
      action:
        description: "Terraform action"
        required: true
        default: "apply"
        type: choice
        options:
          - plan
          - apply
      seed_demo_data:
        description: "Seed demo data into databases (showcase only)"
        required: false
        default: false
        type: boolean

permissions:
  contents: read
  id-token: write

env:
  TERRAFORM_VERSION: "1.6.6"
  TF_IN_AUTOMATION: "true"

jobs:
  # ===========================================
  # Determine Image Tag
  # ===========================================
  prepare:
    name: Prepare deployment
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.get_tag.outputs.tag }}
      environment: ${{ github.event.inputs.environment || 'prod' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Determine image tag
        id: get_tag
        run: |
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            echo "tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
          else
            echo "tag=latest" >> $GITHUB_OUTPUT
          fi

      - name: Display deployment info
        run: |
          echo "============================================"
          echo "Deployment Information"
          echo "============================================"
          echo "Environment: ${{ github.event.inputs.environment || 'prod' }}"
          echo "Image Tag: ${{ steps.get_tag.outputs.tag }}"
          echo "Action: ${{ github.event.inputs.action || 'apply' }}"
          echo "Node Count: ${{ github.event.inputs.node_count || '2' }}"
          echo "Seed Demo Data: ${{ github.event.inputs.seed_demo_data }}"
          echo "============================================"

  # ===========================================
  # Terraform Plan/Apply
  # ===========================================
  terraform:
    name: Terraform ${{ github.event.inputs.action || 'apply' }}
    needs: prepare
    runs-on: ubuntu-latest
    environment: ${{ needs.prepare.outputs.environment }}

    defaults:
      run:
        working-directory: terraform/azure

    outputs:
      resource_group_name: ${{ steps.tf_outputs.outputs.resource_group_name }}
      aks_cluster_name: ${{ steps.tf_outputs.outputs.aks_cluster_name }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup kubectl
        if: github.event.inputs.action == 'apply' && github.event.inputs.seed_demo_data
        uses: azure/setup-kubectl@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Configure Terraform remote state backend (Azure Storage)
        run: |
          cat > backend.tf <<'EOF'
          terraform {
            backend "azurerm" {}
          }
          EOF

      - name: Terraform Init
        env:
          ARM_USE_OIDC: "true"
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: |
          terraform init -input=false \
            -backend-config="resource_group_name=${{ secrets.TFSTATE_RESOURCE_GROUP }}" \
            -backend-config="storage_account_name=${{ secrets.TFSTATE_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=${{ secrets.TFSTATE_CONTAINER }}" \
            -backend-config="key=mtogo.${{ needs.prepare.outputs.environment }}.tfstate"

      # If a previous demo seed Job exists, it will NOT re-run automatically (Jobs are one-shot).
      # We therefore delete any existing mtogo-demo-seed job before apply so Terraform recreates it.
      - name: Pre-apply cleanup demo seed Job (best-effort)
        if: github.event.inputs.action == 'apply' && github.event.inputs.seed_demo_data
        shell: bash
        env:
          ARM_USE_OIDC: "true"
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: |
          set -euo pipefail

          # Outputs are only available if infra already exists (state present).
          set +e
          rg=$(terraform output -raw resource_group_name 2>/dev/null)
          aks=$(terraform output -raw aks_cluster_name 2>/dev/null)
          set -e

          if [ -n "${rg:-}" ] && [ -n "${aks:-}" ]; then
            echo "Fetching AKS credentials for pre-apply seed cleanup..."
            set +e
            az aks get-credentials --resource-group "$rg" --name "$aks" --overwrite-existing
            creds_exit=$?
            set -e

            if [ "$creds_exit" -ne 0 ]; then
              echo "Warning: Failed to fetch AKS credentials (exit code $creds_exit). Skipping pre-apply demo seed Job cleanup; seeding will still be validated post-apply."
              exit 0
            fi

            echo "Deleting any existing demo seed Job(s) so it re-runs..."
            kubectl delete job -n mtogo -l app.kubernetes.io/name=mtogo-demo-seed --ignore-not-found=true || true
          else
            echo "(Skipping pre-apply seed cleanup: Terraform outputs not available yet.)"
          fi

      - name: Terraform Validate
        run: terraform validate

      - name: Terraform Plan
        id: plan
        env:
          ARM_USE_OIDC: "true"
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          TF_VAR_environment: ${{ needs.prepare.outputs.environment }}
          TF_VAR_image_tag: ${{ needs.prepare.outputs.image_tag }}
          TF_VAR_node_count: ${{ github.event.inputs.node_count || '2' }}
          TF_VAR_postgres_admin_password: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
          TF_VAR_github_repository_owner: ${{ github.repository_owner }}
          TF_VAR_ghcr_username: ${{ secrets.GHCR_USERNAME }}
          TF_VAR_ghcr_token: ${{ secrets.GHCR_TOKEN }}
          TF_VAR_management_username: ${{ secrets.MANAGEMENT_USERNAME }}
          TF_VAR_management_password: ${{ secrets.MANAGEMENT_PASSWORD }}
          TF_VAR_discord_webhook_url: ${{ secrets.DISCORD_WEBHOOK_URL }}
          TF_VAR_seed_demo_data: ${{ github.event.inputs.seed_demo_data }}
          # Azure Managed Grafana access is controlled by Azure RBAC.
          # Provide Entra ID object IDs (users or, preferably, groups) as JSON arrays.
          TF_VAR_grafana_slo_admin_principal_ids: ${{ secrets.GRAFANA_SLO_ADMIN_PRINCIPAL_IDS || '[]' }}
          TF_VAR_grafana_kpi_viewer_principal_ids: ${{ secrets.GRAFANA_KPI_VIEWER_PRINCIPAL_IDS || '[]' }}
          TF_VAR_grafana_kpi_editor_principal_ids: ${{ secrets.GRAFANA_KPI_EDITOR_PRINCIPAL_IDS || '[]' }}
        run: terraform plan -out=tfplan -input=false -no-color
        continue-on-error: true

      - name: Terraform Plan Status
        if: steps.plan.outcome == 'failure'
        run: exit 1

      - name: Terraform Apply
        if: github.event.inputs.action == 'apply'
        env:
          ARM_USE_OIDC: "true"
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          TF_VAR_environment: ${{ needs.prepare.outputs.environment }}
          TF_VAR_image_tag: ${{ needs.prepare.outputs.image_tag }}
          TF_VAR_node_count: ${{ github.event.inputs.node_count || '2' }}
          TF_VAR_postgres_admin_password: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
          TF_VAR_github_repository_owner: ${{ github.repository_owner }}
          TF_VAR_ghcr_username: ${{ secrets.GHCR_USERNAME }}
          TF_VAR_ghcr_token: ${{ secrets.GHCR_TOKEN }}
          TF_VAR_management_username: ${{ secrets.MANAGEMENT_USERNAME }}
          TF_VAR_management_password: ${{ secrets.MANAGEMENT_PASSWORD }}
          TF_VAR_discord_webhook_url: ${{ secrets.DISCORD_WEBHOOK_URL }}
          TF_VAR_seed_demo_data: ${{ github.event.inputs.seed_demo_data }}
          # Azure Managed Grafana access is controlled by Azure RBAC.
          # Provide Entra ID object IDs (users or, preferably, groups) as JSON arrays.
          TF_VAR_grafana_slo_admin_principal_ids: ${{ secrets.GRAFANA_SLO_ADMIN_PRINCIPAL_IDS || '[]' }}
          TF_VAR_grafana_kpi_viewer_principal_ids: ${{ secrets.GRAFANA_KPI_VIEWER_PRINCIPAL_IDS || '[]' }}
          TF_VAR_grafana_kpi_editor_principal_ids: ${{ secrets.GRAFANA_KPI_EDITOR_PRINCIPAL_IDS || '[]' }}
        shell: bash
        run: |
          set -euo pipefail

          max_attempts=10
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "============================================"
            echo "Terraform apply (attempt $attempt/$max_attempts)"
            echo "============================================"

            set +e
            output=$(terraform apply -auto-approve -input=false -no-color 2>&1)
            exit_code=$?
            set -e

            echo "$output"

            if [ $exit_code -eq 0 ]; then
              echo "Apply succeeded."
              break
            fi

            # Auto-import resources that already exist, then retry.
            resource_id=$(echo "$output" | sed -n 's/.*A resource with the ID "\([^"]*\)" already exists.*/\1/p' | head -n 1)
            resource_addr=$(echo "$output" | sed -n 's/.*with \([^,]*\),.*/\1/p' | head -n 1)

            if [ -n "$resource_id" ] && [ -n "$resource_addr" ]; then
              echo "Detected existing resource; importing into state:"
              echo "  Address: $resource_addr"
              echo "  ID:      $resource_id"
              terraform import -input=false -no-color "$resource_addr" "$resource_id"
              attempt=$((attempt+1))
              continue
            fi

            echo "Terraform apply failed and no importable resource was detected."
            exit $exit_code
          done

          if [ $attempt -gt $max_attempts ]; then
            echo "Terraform apply failed after $max_attempts attempts."
            exit 1
          fi

      - name: Get Terraform Outputs
        if: github.event.inputs.action == 'apply'
        id: tf_outputs
        env:
          ARM_USE_OIDC: "true"
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: |
          echo "resource_group_name=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT
          echo "aks_cluster_name=$(terraform output -raw aks_cluster_name)" >> $GITHUB_OUTPUT

          echo "website_url=$(terraform output -raw website_url)" >> $GITHUB_OUTPUT
          echo "api_url=$(terraform output -raw api_url)" >> $GITHUB_OUTPUT
          echo "legacy_api_url=$(terraform output -raw legacy_api_url)" >> $GITHUB_OUTPUT
          echo "kpi_grafana_endpoint=$(terraform output -raw kpi_grafana_endpoint)" >> $GITHUB_OUTPUT
          echo "slo_grafana_endpoint=$(terraform output -raw slo_grafana_endpoint)" >> $GITHUB_OUTPUT
          echo "prometheus_query_endpoint=$(terraform output -raw prometheus_query_endpoint)" >> $GITHUB_OUTPUT

          echo "## Access" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "website_url: $(terraform output -raw website_url)" >> $GITHUB_STEP_SUMMARY
          echo "api_url: $(terraform output -raw api_url)" >> $GITHUB_STEP_SUMMARY
          echo "legacy_api_url: $(terraform output -raw legacy_api_url)" >> $GITHUB_STEP_SUMMARY
          echo "kpi_grafana_endpoint: $(terraform output -raw kpi_grafana_endpoint)" >> $GITHUB_STEP_SUMMARY
          echo "slo_grafana_endpoint: $(terraform output -raw slo_grafana_endpoint)" >> $GITHUB_STEP_SUMMARY
          echo "prometheus_query_endpoint: $(terraform output -raw prometheus_query_endpoint)" >> $GITHUB_STEP_SUMMARY

      # NOTE: GitHub OIDC assertions are short-lived. If Terraform apply runs for a long
      # time, Azure CLI may later try to acquire fresh tokens using an expired assertion.
      # Re-login right before Azure CLI steps.
      - name: Azure Login (OIDC refresh for Azure CLI)
        if: github.event.inputs.action == 'apply'
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Grant Grafana Admin to deploy identity
        if: github.event.inputs.action == 'apply'
        shell: bash
        env:
          ARM_USE_OIDC: "true"
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        run: |
          set -euo pipefail

          kpi_id=$(terraform output -raw kpi_grafana_id)
          slo_id=$(terraform output -raw slo_grafana_id)

          # Required for `az grafana data-source ...` calls (otherwise 401 Unauthorized).
          # `--assignee` accepts the application (client) ID.
          az role assignment create --assignee "${{ secrets.AZURE_CLIENT_ID }}" --role "Grafana Admin" --scope "$kpi_id" --only-show-errors || true
          az role assignment create --assignee "${{ secrets.AZURE_CLIENT_ID }}" --role "Grafana Admin" --scope "$slo_id" --only-show-errors || true

          # Give RBAC a moment to propagate.
          sleep 20

      - name: Provision Azure Managed Grafana (dashboards + alerting)
        if: github.event.inputs.action == 'apply'
        shell: pwsh
        env:
          ARM_USE_OIDC: "true"
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          az extension add --name amg --upgrade --yes | Out-Null
          $rg = terraform output -raw resource_group_name
          $kpi = terraform output -raw kpi_grafana_name
          $slo = terraform output -raw slo_grafana_name
          $prom = terraform output -raw prometheus_query_endpoint
          ./provision_grafana.ps1 -ResourceGroupName $rg -KpiGrafanaName $kpi -SloGrafanaName $slo -PrometheusQueryEndpoint $prom

  # ===========================================
  # Post-Deployment Verification
  # ===========================================
  verify:
    name: Verify deployment
    needs: [prepare, terraform]
    if: github.event.inputs.action == 'apply'
    runs-on: ubuntu-latest
    environment: ${{ needs.prepare.outputs.environment }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ needs.terraform.outputs.resource_group_name }} \
            --name ${{ needs.terraform.outputs.aks_cluster_name }} \
            --overwrite-existing

      - name: Wait for deployments
        run: |
          echo "Waiting for deployments to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment --all -n mtogo || true

      - name: Wait for demo seed job (and print logs on failure)
        if: github.event.inputs.seed_demo_data
        shell: bash
        run: |
          set -euo pipefail

          echo "Waiting for demo seed job to complete..."
          seed_job=$(kubectl get jobs -n mtogo -l app.kubernetes.io/name=mtogo-demo-seed -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
          if [ -z "${seed_job:-}" ]; then
            echo "Seed demo data was requested, but no demo seed Job was found in namespace 'mtogo'."
            echo "Existing jobs in mtogo:"
            kubectl get jobs -n mtogo -o wide || true
            exit 1
          fi

          if ! kubectl wait --for=condition=complete --timeout=900s -n mtogo "job/${seed_job}"; then
            echo "Demo seed Job did not complete successfully. Showing diagnostics..."
            kubectl describe -n mtogo "job/${seed_job}" || true
            echo "\nDemo seed Job logs:"
            kubectl logs -n mtogo "job/${seed_job}" --all-containers=true --tail=-1 || true
            exit 1
          fi

      - name: Check pod status
        run: |
          echo "============================================"
          echo "Pod Status"
          echo "============================================"
          kubectl get pods -n mtogo -o wide

          echo ""
          echo "============================================"
          echo "Services"
          echo "============================================"
          kubectl get svc -n mtogo

      - name: Display access URLs
        run: |
          INGRESS_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")

          echo "============================================"
          echo "Access URLs"
          echo "============================================"
          echo "Website: https://${INGRESS_IP}/"
          echo "API Gateway: https://${INGRESS_IP}/api/v1"
          echo "Legacy API: https://${INGRESS_IP}/legacy"
          echo "============================================"
